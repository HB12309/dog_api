package cn.ebing.dog.api.utils.polymorphism;

/**
 * 多态只有在强制转化后，才能使用自己的字段和方法
 */
public class Test {
	public static void main(String[] args) {
		/**
		 * new
		 * 4 . 栈中的数据和堆中的数据销毁并不是同步的。方法一旦结束，栈中的局部变量立即销毁，但是堆中对象不一定销毁。因为可能有其他变量也指向了这个对象，直到栈中没有变量指向堆中的对象时，它才销毁，而且还不是马上销毁，要等垃圾回收扫描时才可以被销毁。
		 *
		 * 类的方法却是该类的所有对象共享的，只有一套，对象使用方法的时候方法才被压入栈，方法不使用则不占用内存。
		 *
		 * 普通变量和引用变量的区别：
		 *
		 * int a = 3; int b = 3； 编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找有没有字面值为3的地址，没找到，就开辟一个存放3这个字面值的地址，然后将a指向3的地址。接着处理int b = 3；在创建完b的引用变量后，由于在栈中已经有3这个字面值，便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况。
		 * 特别注意的是，这种字面值的引用与类对象的引用不同。假定两个类对象的引用同时指向一个对象，如果一个对象引用变量修改了这个对象的内部状态，那么另一个对象引用变量也即刻反映出这个变化。相反，通过字面值的引用来修改其值，不会导致另一个指向此字面值的引用的值也跟着改变的情况。如上例，我们定义完a与b的值后，再令a=4；那么，b不会等于4，还是等于3。在编译器内部，遇到a=4；时，它就会重新搜索栈中是否有4的字面值，如果没有，重新开辟地址存放4的值；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。 （普通变量和引用变量的区别）
		 */
//		show(new Cat());  // 以 Cat 对象调用 show 方法
//		show(new Dog());  // 以 Dog 对象调用 show 方法
//
//		Animal a = new Cat();  // 向上转型
//		a.eat();               // 调用的是 Cat 的 eat
//		Cat c = (Cat)a;        // 向下转型
//		c.work();        // 调用的是 Cat 的 work

		BlackCat blackCat = new BlackCat();
		blackCat.eat();
	}

	public static void show(Animal a)  {
		a.eat();
		// 类型判断
		if (a instanceof Cat)  {  // 猫做的事情
			Cat c = (Cat)a;
			c.work();
		} else if (a instanceof Dog) { // 狗做的事情
			Dog c = (Dog)a;
			c.work();
		}
	}
}